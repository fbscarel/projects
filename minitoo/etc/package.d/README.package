This is the README file for the 'etc/package.d' diretory of the Minitoo build
system.

This directory contains various files with build instructions for packages.
Each file is a Bash script, containing a single function that specifies the
build options to be used by the configure/compile scripts run by Portage, and
also which packages should be installed.

Keep in mind that files with a '.sh' suffix are the ONLY ones loaded by
Minitoo.


Adding new packages
-------------------

It is easy to add new packages to Minitoo, alongside the provided ones. For
example, here we have the 'busybox' package instruction file:

  1  #!/usr/bin/env bash
  2
  3  function pkg_busybox() {
  4    USE="-make-symlinks -mdev -sep-usr"
  5    packages="sys-apps/busybox"
  6  }

The format is pretty simple:

  Line 1) This is the standard shebang (#!) declaring this file should be
          interpreted by the Bash shell.

  Line 3) Here we declare a function that will be loaded by Minitoo. The
          function should be named using the format 'pkg_PACKAGE', where
          'PACKAGE' is the name of the package (or group of packages) that this
          function installs. You could then have 'pkg_apache' or 'pkg_firefox'
          as function names, for example.

  Line 4) This is where we specify the USE flags that Portage is going to use
          while building our package(s). The USE flags, simply put, are
          compilation options for the package that can enable or disable
          program features and dependencies. You should review which USE flags
          are available for the package you wish to install, and set them
          accordingly. Global USE flags can be checked on the
          '/usr/portage/profiles/use.desc' file, and local (i.e. per-package)
          USE flags can be found on the '/usr/portage/profiles/use.local.desc'
          file.

  Line 5) Here we list the package (or packages) that this function will
          install. You can use any of the formats accepted by 'emerge', that
          is: ebuilds, tbz2files, files, sets or atoms.
          
          You will usually want to specify a package using the common
          'category/package_name' format or (if needed) select a specific
          version number of the package you wish to install using the '<', '>'
          and '=' atoms. For example, you may select the 'x11-wm/fluxbox'
          package, or the '=x11-libs/gtk+-2.24.2' package version.

After creating the package instruction file, it's pretty simple to add it to
the Minitoo build system. Add your function name (created on 'Line 3' on the
example above), without the 'pkg_' prefix, to the package list given to the
'-p' commandline option or the 'INSTALL_PACKAGES' configuration file parameter.

That's it! Your new package should now be built and installed without trouble.


Package dependencies
--------------------

It's true that, by using Portage, we have full package management and dependency
resolution done automatically for us. However, that raises an important
question: how to enforce specific (and, perhaps, conflicting) local USE flags
for each package?

To solve that problem, Minitoo supports dependency functions. A dependency
function is in fact a very simple entity, as shown in the example below:

  function pkg_xorg_depends() {
    depends="glibc udev"
  }

That's it. Easy, right? All that's needed to declare a dependency function is
creating a new function with the same name used in the previous section, "Adding
new packages", and appending the suffix '_depends'. Inside the function, we
declare a single variable, 'depends', and assign to it a space-separated list of
dependencies this package needs to be installed.

Keep in mind that only packages registered inside Minitoo should be included in
the list assigned to the 'depends' variable. Packages that are otherwise
recognized as valid by Portage but have not yet been added to Minitoo cannot be
considered valid dependencies.

This feature does not imply, in any way whatsoever, that you should track and
write down every single dependency your package has before installing it. This
is simply a convenience feature to enforce an installation order for Minitoo to
stick to. Using this order, it's possible to to ensure that the local USE
flags you specifically want applied to each package installation actually
affect the final build.

To give a better example as for why you would want/need to use dependency
functions in your packages, consider the following scenario: you want to install
packages X and Y, and Y depends on X to be installed. What's more, each package
has a specific set of custom-tailored USE flags you have configured.

If no order is enforced, Minitoo can attempt to install X before Y, and
everything goes as planned. However, we can get unlucky and Y gets installed
before X; Portage detects that X is a dependency for Y, and automatically pulls
it for installation. Since the local USE flags you selected for X are not loaded
in this scenario, X will be installed with the default USE flags, plus the
global ones defined in 'etc/portage/make.conf'. With no custom USE flags,
package X could then pull in a host of other dependencies that you otherwise
carefully removed in the package file, rendering all your work useless.

By enforcing a dependency for package Y on package X, Minitoo will know that
it's supposed to install X _BEFORE_ installing Y. Your USE flags are correctly
parsed, and Portage pulls no additional dependencies. Success!


Creating hook functions
-----------------------

In addition to simply installing new packages using Portage, as explained
above, you may also need to do some advanced or custom actions to install and
configure software on your minimal systems. The Linux kernel and bootloaders
are good examples of cases where this kind of control is needed, but it also
extends to software not included in the Portage database, as well as
configuration steps that need to be automated.

Minitoo offers support for so-called "hook functions", which is a fancy way of
calling functions that are invoked as-is when installing a package. This, as
stated before, is very useful to configure a package that was recently
installed, and is also a handy way to install software that is not meant to be
handled by emerge/Portage.

A good example is the 'etc/package.d/extlinux.sh' package instruction file.
Look at its function name:

  function pkg_extlinux_hook() {

Much like standard package installation functions, hook functions have a
specific naming pattern. You should use a name in the format
'pkg_PACKAGE_hook', where 'PACKAGE' is the name of the package you wish to
install or configure. A package may have a standard 'install' function (as
explained in the previous section) and a hook function simultaneously. It is
also possible to have only an install function, or only a hook function, if
appropriate.

Since hook functions are executed as-is, you can do pretty much anything you
want with them, as long as it's valid Bash code. Of course, you might need a
few variables to make your job easier, and luckily enough Minitoo provides some
global variables for that purpose.


Here's a list of the most useful variables available to hook functions:

  $build_dir:        directory where the minimal system is being installed, as
                     set by the '-b' commandline option or the 'BUILD_DIR'
                     configuration file parameter. You can chroot to this
                     directory to execute 'native' calls, if needed.

  $conf_dir:         directory where configuration files reside.

  $device:           the block device that was formatted/mounted during disk
                     preparation.

  $deploy_dir:       directory that will be deployed after package
                     installation. You may want to copy or refer to files that
                     are contained in this directory even before deployment.

  $install_packages: a space-separated list of packages that are being
                     installed on the minimal system. You might have to parse
                     this list in order to find a specific package.

  $kver:             kernel version being compiled and installed.

  $kconfig:          configuration file used to compile the kernel above.


Besides variables, there's also a number of helpful functions that you may use:

  check_verb $1:     check if running of verbose mode. If true, print string $1
                     to stdout. The pattern used by Minitoo for output messages
                     is preceding informational messages with '[*]' and error
                     messages with '[!]'.

  check_yes $1:      prompt the user with question $1 and return response code.
                     If the answer was 'yes', the function returns '1', else it
                     returns '0'. The only valid answers are '[YyNn]'; all other
                     characters/strings are ignored and the question is asked
                     again. Usually, questions are terminated with the available
                     options to help the user, as in: '(y/n)'.

  exit_generic:      takes no arguments. Ends the program abruptly with a
                     generic "Terminating due to user input" message. Use
                     sparingly.
