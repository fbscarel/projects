#!/usr/bin/env bash
# dnsbrute.sh, 2014/10/22 14:11:44 fbscarel $

DNSBRUTE_HOME="$( readlink -f $0 | sed 's/\/[^\/]*$//' | sed 's/\/[^\/]*$//' )"
PROGNAME="$( basename $0 )"

## file paths
#
LOGPARSE="$DNSBRUTE_HOME/bin/logparse.sh"
CONFIG="$DNSBRUTE_HOME/etc/dnsbrute.conf"
FILE_UTILS="$DNSBRUTE_HOME/lib/file.sh"
IP_UTILS="$DNSBRUTE_HOME/lib/ip.sh"

## assumed defaults, if unspecified
#
DEFAULT_WDIR="$DNSBRUTE_HOME/var/whitelists"
DEFAULT_TSERVER="8.8.8.8"


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


## lookup domain $1 from server $2
#
getdomain() {
  [ "$recurse" = true ] && local rec="+recurse" || local rec="+norecurse"
  local retval="$( dig +noall +answer +short $rec $1 $2 A | sort -n | tr '\n' ' ' )"
  echo "$( nocname "$retval" )"
}


## parse configuration file for parameters
#
parse_conf() {
  [ -z "$tserver" ]  && tserver="$( getparam TRUSTED_SERVER $CONFIG )"
  [ -z "$sservers" ] && sservers="$( getparam SUSPICIOUS_SERVERS $CONFIG )"
  [ -z "$wdir" ]     && wdir="$( getparam WHITELIST_DIR $CONFIG )"

  return 0
}


## show program usage and exit
#
usage() {
  echo "Usage: $( basename $0 ) -d DOMAIN_FILE [-o OUTFILE] [-r] [-s SUSPSERVER_FILE]" 1>&2
  echo "                    [-t TRUSTED_SERVER] [-w WHITELIST_DIR]"
  echo "Lookup various suspicious DNS servers for an arbitrary number of domains,"
  echo "comparing results against a trusted server. Report discrepancies for further"
  echo "action on a number of formats, including CSV, syslog and email."
  echo
  echo "Some program parameters can be set via configuration file, as explained below,"
  echo "which can be found in 'etc/dnsbrute.conf'."
  echo
  echo "Available options:"
  echo "  -d          List of domains to be looked up and compared. Mandatory."
  echo "  -h          Show this help screen and exit."
  echo "  -l          Invoke 'logparse.sh' after execution to process results. The"
  echo "              parameter passed to this option will be passed over verbatim."
  echo "              You MUST enclose this parameter using double-quotes, otherwise"
  echo "              it will be interpreted as being passed directly to $PROGNAME ."
  echo "              It is not necessary, however, to specify the logfile to be"
  echo "              processed, as it's implicit. Check the 'logparse.sh' online help"
  echo "              option ('-h') for usage information."
  echo "  -o          Specify alternative outfile to log output into. If unspecified,"
  echo "              'var/dnsbrute.sh.\$TIMESTAMP.out' will be used. \$TIMESTAMP"
  echo "              format is Unix epoch."
  echo "  -r          Toggle RD (recursion desired) bit in DNS queries. If unspecified,"
  echo "              queries will be non-recursive by default."
  echo "  -s          Specify file containing a list of suspicious servers to be looked"
  echo "              up against. This file should contain one IP address per line. The"
  echo "              file 'etc/sample_sservers.db' contains examples of accepted"
  echo "              formats. Mandatory. Can be set via configuration file."
  echo "  -t          Specify trusted server to be looked up against. The responses"
  echo "              given by this server will be used for comparison with the '-s'"
  echo "              list of suspicious servers for validity. If unspecified, the"
  echo "              Google DNS Server (8.8.8.8) will be used. Can be set via"
  echo "              configuration file."
  echo "  -w          Specify directory where whitelists will be searched. Whitelists"
  echo "              can be generated using the 'bin/getrange.sh' helper script. If"
  echo "              unspecified, 'var/whitelists' will be used by default. Can be"
  echo "              set via configuration file."
  exit 1
}


## print informative header to $outfile
#
print_header() {
  echo "# Generated by $PROGNAME on `date`" >> $outfile
  echo "# CSV File format:" >> $outfile
  echo "#">> $outfile
  echo "# Domain, Suspicious DNS, Suspicious reported IP, Trusted DNS, Trusted reported IPs" >> $outfile
  echo "#">> $outfile
}


# - - -  main()  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


. $FILE_UTILS
. $IP_UTILS

# check for parameters
while getopts "d:l:o:s:t:w:hr" opt; do
    case "$opt" in
        h) usage ;;
        d) domains=${OPTARG} ;;
        l) logline=${OPTARG} ;;
        o) outfile=${OPTARG} ;;
        r) recurse=true ;;
        s) sservers=${OPTARG} ;;
        t) tserver=${OPTARG} ;;
        w) wdir=${OPTARG} ;;
        *) usage ;;
    esac
done
shift $((OPTIND-1))

# parse configuration file, do not override commandline options
[ -f "$CONFIG" ] && parse_conf || echo "[!] Configuration file $CONFIG not found, continuing..."

# check mandatory options
[ -z "$domains" ]   && { echo "[!] Option '-d' is mandatory!"; usage; }
[ -z "$sservers" ]  && { echo "[!] Option '-s' is mandatory!"; usage; }

# if still unset, give default values to non-mandatory parameters
[ -z "$outfile" ]   && outfile="$DNSBRUTE_HOME/var/$PROGNAME.`date +%s`.out"
[ -z "$tserver" ]   && tserver="$DEFAULT_TSERVER"
[ -z "$wdir" ]      && wdir="$DEFAULT_WDIR"

# check if file paths passed to the program actually exist
check_file $domains
check_file $sservers
check_dir  $wdir

# check if trusted server's IP address is valid
if ! validip $tserver; then
  echo "[!] IP $tserver is invalid, terminating."
  exit 1
fi

print_header

while read domain; do
  if check_comment "$domain"; then continue; fi
  trusted="$( getdomain $domain $tserver )"

  while read dns; do
    if check_comment "$dns"; then continue; fi
    suspicious="$( getdomain $domain $dns )"

    for ip in $suspicious; do
      # IP not found on trusted result set?
      if [[ $trusted != *$ip* ]]; then
        ia=( $(echo_range $ip) )

        # search IP range on whitelists
        flag=0
        for i in ${ia[@]}; do
          [ "$( egrep -ci $i $wdir/* | cut -d ':' -f 2 | sort -n | tail -n1 )" -ne 0 ] && flag=1
        done
        
        [ "$flag" -eq 0 ] && echo "$domain,$dns,$ip,$tserver,$trusted" >> $outfile
      fi
    done
  done < $sservers
done < $domains

# process outfile using log parser, if requested
[ -n "$logline" ] && $LOGPARSE -l $outfile $logline
