#!/usr/bin/env bash
# dnsbrute.sh, 2014/10/24 12:44:17 fbscarel $

DNSBRUTE_HOME="$( readlink -f $0 | sed 's/\/[^\/]*$//' | sed 's/\/[^\/]*$//' )"
PROGNAME="$( basename $0 )"

## file paths
#
LOGPARSE="$DNSBRUTE_HOME/bin/logparse.sh"
CONFIG="$DNSBRUTE_HOME/etc/dnsbrute.conf"
DNS_UTILS="$DNSBRUTE_HOME/lib/dns.sh"
FILE_UTILS="$DNSBRUTE_HOME/lib/file.sh"
IP_UTILS="$DNSBRUTE_HOME/lib/ip.sh"

## network parameters
#
DIG_TIMEOUT=2

## assumed defaults, if unspecified
#
DEFAULT_QTYPE="A"
DEFAULT_RDIR="$DNSBRUTE_HOME/var/results"
DEFAULT_WDIR="$DNSBRUTE_HOME/var/whitelists"
DEFAULT_TSERVER="8.8.8.8"


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


## parse configuration file for parameters
#
parse_conf() {
  [ -z "$tserver" ]  && tserver="$( getparam TRUSTED_SERVER $CONFIG )"
  [ -z "$sservers" ] && sservers="$( getparam SUSPICIOUS_SERVERS $CONFIG )"
  [ -z "$wdir" ]     && wdir="$( getparam WHITELIST_DIR $CONFIG )"

  return 0
}


## show program usage and exit
#
usage() {
  echo "Usage: $( basename $0 ) -d DOMAIN_FILE [-o OUTFILE] [-r] [-s SUSPSERVER_FILE]" 1>&2
  echo "                    [-t TRUSTED_SERVER] [-w WHITELIST_DIR]"
  echo "Lookup various suspicious DNS servers for an arbitrary number of domains,"
  echo "comparing results against a trusted server. Report discrepancies for further"
  echo "action on a number of formats, including CSV, syslog and email."
  echo
  echo "Some program parameters can be set via configuration file, as explained below,"
  echo "which can be found in 'etc/dnsbrute.conf'."
  echo
  echo "Available options:"
  echo "  -a          Toggle '+aaonly' flag on DNS queries, which will only report"
  echo "              authoritative answers. If unspecified, queries will also return"
  echo "              non-authoritative results by default."
  echo "  -d          List of domains to be looked up and compared. Mandatory."
  echo "  -h          Show this help screen and exit."
  echo "  -l          Invoke 'logparse.sh' after execution to process results. The"
  echo "              parameter passed to this option will be passed over verbatim."
  echo "              You MUST enclose this parameter using double-quotes, otherwise"
  echo "              it will be interpreted as being passed directly to $PROGNAME ."
  echo "              It is not necessary, however, to specify the logfile to be"
  echo "              processed, as it's implicit. Check the 'logparse.sh' online help"
  echo "              option ('-h') for usage information."
  echo "  -o          Specify alternative outfile to log output into. If unspecified,"
  echo "              'var/results/dnsbrute.sh.\$TIMESTAMP.out' will be used."
  echo "              \$TIMESTAMP format is Unix epoch."
  echo "  -q          Query type to be performed. If unspecified, the default is an A"
  echo "              (address) query. Available types: A, MX, NS, SOA."
  echo "  -r          Toggle RD (recursion desired) bit in DNS queries. If unspecified,"
  echo "              queries will be non-recursive by default."
  echo "  -s          Specify file containing a list of suspicious servers to be looked"
  echo "              up against. This file should contain one IP address per line. The"
  echo "              file 'etc/sample_sservers.db' contains examples of accepted"
  echo "              formats. Mandatory. Can be set via configuration file."
  echo "  -t          Specify trusted server to be looked up against. The responses"
  echo "              given by this server will be used for comparison with the '-s'"
  echo "              list of suspicious servers for validity. If unspecified, the"
  echo "              Google DNS Server (8.8.8.8) will be used. Can be set via"
  echo "              configuration file."
  echo "  -w          Specify directory where whitelists will be searched. Whitelists"
  echo "              can be generated using the 'bin/getrange.sh' helper script. If"
  echo "              unspecified, 'var/whitelists' will be used by default. Can be"
  echo "              set via configuration file."
  exit 1
}


## print informative header to $outfile
#
print_header() {
  echo "# Generated by $PROGNAME on `date`" >> $outfile
  echo "#">> $outfile
}


# - - -  main()  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


. $DNS_UTILS
. $FILE_UTILS
. $IP_UTILS

# check for parameters
while getopts "d:l:o:q:s:t:w:har" opt; do
    case "$opt" in
        h) usage ;;
        a) aaonly=true ;;
        d) domains=${OPTARG} ;;
        l) logline=${OPTARG} ;;
        o) outfile=${OPTARG} ;;
        q) qtype=${OPTARG} ;;
        r) recurse=true ;;
        s) sservers=${OPTARG} ;;
        t) tserver=${OPTARG} ;;
        w) wdir=${OPTARG} ;;
        *) usage ;;
    esac
done
shift $((OPTIND-1))

# parse configuration file, do not override commandline options
[ -f "$CONFIG" ] && parse_conf || echo "[!] Configuration file $CONFIG not found, continuing..."

# check mandatory options
[ -z "$domains" ]   && { echo "[!] Option '-d' is mandatory!"; usage; }
[ -z "$sservers" ]  && { echo "[!] Option '-s' is mandatory!"; usage; }

# if still unset, give default values to non-mandatory parameters
[ -z "$qtype" ]     && qtype="$DEFAULT_QTYPE"
[ -z "$outfile" ]   && outfile="$DEFAULT_RDIR/$PROGNAME.`date +%s`.out"
[ -z "$tserver" ]   && tserver="$DEFAULT_TSERVER"
[ -z "$wdir" ]      && wdir="$DEFAULT_WDIR"

# check if file paths passed to the program actually exist
check_file $domains
check_file $sservers
check_dir  $wdir

# check if trusted server's IP address is valid
if ! validip $tserver; then
  echo "[!] IP $tserver is invalid, terminating."
  exit 1
fi

# check if query type is valid
qtype="$( echo $qtype | tr '[:lower:]' '[:upper:]' )"
if [ "$qtype" != "A" ]  && [ "$qtype" != "MX" ] &&
   [ "$qtype" != "NS" ] && [ "$qtype" != "SOA" ]; then
  echo "[!] Invalid query type specified, terminating."
  exit 1
fi

print_header

# make queries according to $qtype
case "$qtype" in
  "A")   query_A   $domains $sservers $outfile $tserver ;;
  "MX")  query_MX  $domains $sservers $outfile $tserver ;;
  "NS")  query_NS  $domains $sservers $outfile $tserver ;;
  "SOA") query_SOA $domains $sservers $outfile $tserver ;;
esac

# process outfile using log parser, if requested
[ -n "$logline" ] && $LOGPARSE -l $outfile $logline
